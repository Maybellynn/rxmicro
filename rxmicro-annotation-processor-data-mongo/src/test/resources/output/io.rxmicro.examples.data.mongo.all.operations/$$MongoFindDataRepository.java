package io.rxmicro.examples.data.mongo.all.operations;

import com.mongodb.reactivestreams.client.FindPublisher;
import com.mongodb.reactivestreams.client.MongoDatabase;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import io.rxmicro.data.Pageable;
import io.rxmicro.data.SortOrder;
import io.rxmicro.data.detail.adapter.PublisherToFluxFutureAdapter;
import io.rxmicro.data.detail.adapter.PublisherToOptionalMonoFutureAdapter;
import io.rxmicro.data.detail.adapter.PublisherToRequiredMonoFutureAdapter;
import io.rxmicro.data.mongo.ProjectionType;
import io.rxmicro.data.mongo.detail.AbstractMongoRepository;
import io.rxmicro.examples.data.mongo.all.operations.model.$$AccountEntityFromMongoDBConverter;
import io.rxmicro.examples.data.mongo.all.operations.model.Account;
import io.rxmicro.examples.data.mongo.all.operations.model.Role;
import org.bson.Document;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.stream.Collectors;

/**
 * Generated by {@code RxMicro Annotation Processor}
 */
public final class $$MongoFindDataRepository extends AbstractMongoRepository implements FindDataRepository {

    private final $$AccountEntityFromMongoDBConverter accountEntityFromMongoDBConverter =
            new $$AccountEntityFromMongoDBConverter();

    public $$MongoFindDataRepository(final MongoDatabase mongoDatabase) {
        super(FindDataRepository.class, mongoDatabase.getCollection("collection"));
    }

    @Override
    public Mono<Account> findById1(final long id) {
        // query = "{_id: ?}
        final Document query = new Document("_id", id);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return Mono.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Mono<Account> findByRole1(final Role role) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return Mono.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Flux<Account> findAll1() {
        // sort = "{balance: -1}
        final Document sort = new Document("balance", -1);
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(20)
                .skip(5)
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Flux<Account> findAll1(final SortOrder sortOrder) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Mono<List<Account>> findAll1(final SortOrder sortOrder, final Pageable pageable) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collectList();
    }

    @Override
    public Flux<Account> findFiltered1(final Role role, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Mono<List<Account>> findFiltered1(final String name, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{$or: [{firstName: ?}, {lastName: ?}]}
        final Document query = new Document("$or", name);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collectList();
    }

    @Override
    public Flux<Account> findProjection1(final Pageable pageable) {
        // projection = "{firstName: 1, lastName: 1}
        final Document projection = new Document()
                .append("firstName", 1)
                .append("lastName", 1);
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Mono<List<Account>> findProjection1(final ProjectionType firstName, final ProjectionType lastName, final SortOrder sortOrder, final Pageable pageable) {
        // projection = "{firstName: ?, lastName: ?}
        final Document projection = new Document()
                .append("firstName", firstName.mongo())
                .append("lastName", lastName.mongo());
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flux.from(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collectList();
    }

    @Override
    public Single<Account> findById2(final long id) {
        // query = "{_id: ?}
        final Document query = new Document("_id", id);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return Single.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Maybe<Account> findByRole2(final Role role) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .firstElement()
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Flowable<Account> findAll2() {
        // sort = "{balance: -1}
        final Document sort = new Document("balance", -1);
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(20)
                .skip(5)
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Flowable<Account> findAll2(final SortOrder sortOrder) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Single<List<Account>> findAll2(final SortOrder sortOrder, final Pageable pageable) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collect(ArrayList::new, (l, e) -> l.add(e));
    }

    @Override
    public Flowable<Account> findFiltered2(final Role role, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Single<List<Account>> findFiltered2(final String name, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{$or: [{firstName: ?}, {lastName: ?}]}
        final Document query = new Document("$or", name);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collect(ArrayList::new, (l, e) -> l.add(e));
    }

    @Override
    public Flowable<Account> findProjection2(final Pageable pageable) {
        // projection = "{firstName: 1, lastName: 1}
        final Document projection = new Document()
                .append("firstName", 1)
                .append("lastName", 1);
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public Single<List<Account>> findProjection2(final ProjectionType firstName, final ProjectionType lastName, final SortOrder sortOrder, final Pageable pageable) {
        // projection = "{firstName: ?, lastName: ?}
        final Document projection = new Document()
                .append("firstName", firstName.mongo())
                .append("lastName", lastName.mongo());
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return Flowable.fromPublisher(result)
                .map(accountEntityFromMongoDBConverter::fromDB)
                .collect(ArrayList::new, (l, e) -> l.add(e));
    }

    @Override
    public CompletableFuture<Account> findById3(final long id) {
        // query = "{_id: ?}
        final Document query = new Document("_id", id);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return new PublisherToRequiredMonoFutureAdapter<>(
                result,
                useOptionalExceptionSupplier(CompletableFuture.class, Account.class)
        ).thenApply(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public CompletableFuture<Optional<Account>> findByRole3(final Role role) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return new PublisherToOptionalMonoFutureAdapter<>(result)
                .thenApply(o -> o.map(accountEntityFromMongoDBConverter::fromDB));
    }

    @Override
    public CompletableFuture<List<Account>> findAll3() {
        // sort = "{balance: -1}
        final Document sort = new Document("balance", -1);
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(20)
                .skip(5)
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findAll3(final SortOrder sortOrder) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findAll3(final SortOrder sortOrder, final Pageable pageable) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findFiltered3(final Role role, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findFiltered3(final String name, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{$or: [{firstName: ?}, {lastName: ?}]}
        final Document query = new Document("$or", name);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findProjection3(final Pageable pageable) {
        // projection = "{firstName: 1, lastName: 1}
        final Document projection = new Document()
                .append("firstName", 1)
                .append("lastName", 1);
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletableFuture<List<Account>> findProjection3(final ProjectionType firstName, final ProjectionType lastName, final SortOrder sortOrder, final Pageable pageable) {
        // projection = "{firstName: ?, lastName: ?}
        final Document projection = new Document()
                .append("firstName", firstName.mongo())
                .append("lastName", lastName.mongo());
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<Account> findById4(final long id) {
        // query = "{_id: ?}
        final Document query = new Document("_id", id);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return new PublisherToRequiredMonoFutureAdapter<>(
                result,
                useOptionalExceptionSupplier(CompletionStage.class, Account.class)
        ).thenApply(accountEntityFromMongoDBConverter::fromDB);
    }

    @Override
    public CompletionStage<Optional<Account>> findByRole4(final Role role) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        final FindPublisher<Document> result = collection
                .find(query)
                .returnKey(false);
        return new PublisherToOptionalMonoFutureAdapter<>(result)
                .thenApply(o -> o.map(accountEntityFromMongoDBConverter::fromDB));
    }

    @Override
    public CompletionStage<List<Account>> findAll4() {
        // hint = "{balance: 1}
        final Document hint = new Document("balance", 1);
        // sort = "{balance: -1}
        final Document sort = new Document("balance", -1);
        final FindPublisher<Document> result = collection
                .find()
                .hint(hint)
                .sort(sort)
                .limit(20)
                .skip(5)
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findAll4(final SortOrder sortOrder) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findAll4(final SortOrder sortOrder, final Pageable pageable) {
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findFiltered4(final Role role, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{role: ?}
        final Document query = new Document("role", role);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findFiltered4(final String name, final SortOrder sortOrder, final Pageable pageable) {
        // query = "{$or: [{firstName: ?}, {lastName: ?}]}
        final Document query = new Document("$or", name);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find(query)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findProjection4(final Pageable pageable) {
        // projection = "{firstName: 1, lastName: 1}
        final Document projection = new Document()
                .append("firstName", 1)
                .append("lastName", 1);
        // hint = "{balance: 1}
        final Document hint = new Document("balance", 1);
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .hint(hint)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }

    @Override
    public CompletionStage<List<Account>> findProjection4(final ProjectionType firstName, final ProjectionType lastName, final SortOrder sortOrder, final Pageable pageable) {
        // projection = "{firstName: ?, lastName: ?}
        final Document projection = new Document()
                .append("firstName", firstName.mongo())
                .append("lastName", lastName.mongo());
        // hint = "{balance: 1}
        final Document hint = new Document("balance", 1);
        // sort = "{balance: ?}
        final Document sort = new Document("balance", sortOrder.mongo());
        final FindPublisher<Document> result = collection
                .find()
                .projection(projection)
                .hint(hint)
                .sort(sort)
                .limit(pageable.getLimit())
                .skip(pageable.getOffset())
                .returnKey(false);
        return new PublisherToFluxFutureAdapter<>(result)
                .thenApply(l -> l.stream().map(accountEntityFromMongoDBConverter::fromDB)
                        .collect(Collectors.toList()));
    }
}
