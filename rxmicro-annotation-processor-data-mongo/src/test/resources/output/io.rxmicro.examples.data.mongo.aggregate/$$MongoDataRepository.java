package io.rxmicro.examples.data.mongo.aggregate;

import com.mongodb.reactivestreams.client.AggregatePublisher;
import com.mongodb.reactivestreams.client.MongoDatabase;
import io.rxmicro.data.mongo.detail.AbstractMongoRepository;
import io.rxmicro.examples.data.mongo.aggregate.model.$$ReportEntityFromMongoDBConverter;
import io.rxmicro.examples.data.mongo.aggregate.model.Report;
import org.bson.Document;
import reactor.core.publisher.Flux;

import java.util.Arrays;
import java.util.List;

/**
 * Generated by rxmicro annotation processor
 *
 * @link https://rxmicro.io
 */
public final class $$MongoDataRepository extends AbstractMongoRepository implements DataRepository {

    private final $$ReportEntityFromMongoDBConverter reportEntityFromMongoDBConverter =
            new $$ReportEntityFromMongoDBConverter();

    public $$MongoDataRepository(final MongoDatabase mongoDatabase) {
        super(DataRepository.class, mongoDatabase.getCollection("account"));
    }

    @Override
    public Flux<Report> aggregate() {
        // pipeline0 = "{ $group : { _id: '$role', total : { $sum: '$balance'}} }
        final Document pipeline0 = new Document()
                .append("$group", new Document()
                        .append("_id", "$role")
                        .append("total", new Document()
                                .append("$sum", "$balance")
                        )
                );
        // pipeline1 = "{ $sort: {total: -1, _id: -1} }
        final Document pipeline1 = new Document()
                .append("$sort", new Document()
                        .append("total", -1)
                        .append("_id", -1)
                );
        final List<Document> pipeline = Arrays.asList(pipeline0, pipeline1);
        final AggregatePublisher<Document> result = collection
                .aggregate(pipeline)
                .allowDiskUse(false);
        return Flux.from(result)
                .map(reportEntityFromMongoDBConverter::fromDB);
    }
}
